{{define "outputmapexpander"}}map[string]interface{} {
	{{range $key, $value := .Children}}
	{{if eq $value.Type "map"}}
	"{{$key}}": {{template "outputmapexpander" $value}},
	{{else}}
	"{{$key}}": maybe({{$value.FlowName}}_expr_{{$value.ExpressionSrno}}(expr_map)),
	{{end}}
	{{end}}
}{{end}}
package workflows
{{if .OrigSpec.References.go}}
import (
	config "github.com/grofers/go-codon/runtime/config"
	{{range $index, $element := .OrigSpec.References.go}}
	{{$index}} "{{$element}}"
	{{end}}
)
{{end}}

func {{ pascalize .OrigSpec.Name }}(var_map map[string]interface{}) interface{} {
	var err interface{}
	err = nil

	var var_map_mutex = &sync.RWMutex{}
	{{ if eq (len .OrigSpec.Start) 1 }}
	{{printf "task_%s__%s" $.OrigSpec.Name (index $.OrigSpec.Start 0)}}(var_map, var_map_mutex)
	{{ else if gt (len .OrigSpec.Start) 1 }}
	var wg sync.WaitGroup
	wg.Add({{len .OrigSpec.Start}})
	{{ range $index, $element := .OrigSpec.Start }}
	go func() {
		defer func () {
			if r := recover(); r != nil {
				err = r
			}
			wg.Done()
		}()
		{{printf "task_%s__%s" $.OrigSpec.Name $element}}(var_map, var_map_mutex)
	}()
	{{ end }}
	wg.Wait()
	{{ end }}

	if err != nil {
		panic(err)
	}

	expr_map := make(map[string]interface{})
	expr_map["main"] = var_map
	expr_map["constants"] = config.YmlConfig.Constants

	defer var_map_mutex.RUnlock()
	var_map_mutex.RLock()
	{{if eq .LanguageSpec.OutputObj.Type "map"}}
	ret_map := {{template "outputmapexpander" .LanguageSpec.OutputObj}}
	{{else}}
	ret_map := maybe({{$.OrigSpec.Name}}_expr_{{.LanguageSpec.OutputObj.ExpressionSrno}}(expr_map))
	{{end}}

	return ret_map
}

{{range $expr, $expr_obj := .ExpressionMap}}
{{if eq $expr_obj.Type "jmes"}}var {{$.OrigSpec.Name}}_eval_{{$expr_obj.Srno}} = jmespath.MustCompile("{{escapestring $expr_obj.Raw}}"){{end}}{{if eq $expr_obj.Type "jngo"}}var {{$.OrigSpec.Name}}_eval_{{$expr_obj.Srno}} = pongo2.Must(pongo2.FromString("{{escapestring $expr_obj.Raw}}")){{end}}{{end}}

{{range $index, $element := .OrigSpec.Tasks}}
func {{printf "task_%s__%s" $.OrigSpec.Name $index}}(var_map map[string]interface{}, var_map_mutex *sync.RWMutex) error {
	expr_map := make(map[string]interface{})
	expr_map["main"] = var_map
	expr_map["constants"] = config.YmlConfig.Constants

	logger := tasklogger {}
	logger.setLogExpressions({{$.OrigSpec.Name}}_expr_{{ (index $.ExpressionMap $element.Logging.Expressions).Srno }}(expr_map))
	logger.setLogFlow({{$.OrigSpec.Name}}_expr_{{ (index $.ExpressionMap $element.Logging.Flow).Srno }}(expr_map))
	logger.setLogActions({{$.OrigSpec.Name}}_expr_{{ (index $.ExpressionMap $element.Logging.Actions).Srno }}(expr_map))

	var err error
	is_error := false

	{{ if $element.Action }}
	arg_map := make(map[string]interface{})
	{{if gt (len $element.Input) 0}}
	func() {
		defer var_map_mutex.RUnlock()
		var_map_mutex.RLock()
		var exerr error
		logger.logExpressionf("[DEBUG] Mapping arguments using main bucket %v ...", expr_map["main"])
		{{range $index2, $element2 := $element.Input}}
		arg_map["{{$index2}}"], exerr = {{$.OrigSpec.Name}}_expr_{{ (index $.ExpressionMap $element2).Srno }}(expr_map)
		if exerr != nil {
			logger.logExpressionf("[WARN] Evaluating {{escapestring (index $.ExpressionMap $element2).Type}} expression {{escapestring (index $.ExpressionMap $element2).Raw}} for argument {{$index2}}. Failure: %v", exerr)
		} else {
			logger.logExpressionf("[DEBUG] Evaluating {{escapestring (index $.ExpressionMap $element2).Type}} expression {{escapestring (index $.ExpressionMap $element2).Raw}} for argument {{$index2}}. Result: %v", arg_map["{{$index2}}"])
		}
		{{end}}
	}()
	{{end}}
	{{if $element.Timeout}}arg_map["_timeout"] = int64({{$element.Timeout}}){{end}}

	{{ if eq (index $.ActionMap $element.Action).Type "clients" }}
	logger.logActionf("[DEBUG] Sending a request to {{ (index $.ActionMap $element.Action).Pascalized }} API")
	resp, rerr := {{ (index $.ActionMap $element.Action).Pascalized }}(arg_map)
	err = rerr
	if err == nil {
		resp_map := resp.Payload
		logger.logActionf("[DEBUG] Received response from {{ (index $.ActionMap $element.Action).Pascalized }} API: %v", resp_map)
		expr_map["action"] = resp_map
	}
	{{ else }}
	logger.logActionf("[DEBUG] Executing custom action {{ (index $.ActionMap $element.Action).Pascalized }}")
	resp, rerr := {{ (index $.ActionMap $element.Action).Pascalized }}(arg_map)
	err = rerr
	if err == nil {
		logger.logActionf("[DEBUG] Result of custom action {{ (index $.ActionMap $element.Action).Pascalized }}: %v", resp)
		expr_map["action"] = resp
	}
	{{ end }}

	{{ else if $element.WithItems }}
	var perr interface{} = nil
	var wg sync.WaitGroup
	var iterlist_interface interface{}
	var iterlist []interface{}
	var_maps := []map[string]interface{} {}
	err_objs := []*error {}

	func() {
		defer var_map_mutex.RUnlock()
		var_map_mutex.RLock()
		iterlist_interface, err = {{$.OrigSpec.Name}}_expr_{{ (index $.ExpressionMap $element.WithItems).Srno }}(expr_map)
		if err == nil {
			logger.logExpressionf("[DEBUG] Evaluating {{escapestring (index $.ExpressionMap $element.WithItems).Type}} expression {{escapestring (index $.ExpressionMap $element.WithItems).Raw}} for iteration. Result: %v", iterlist_interface)
		} else {
			logger.logExpressionf("[DEBUG] Evaluating {{escapestring (index $.ExpressionMap $element.WithItems).Type}} expression {{escapestring (index $.ExpressionMap $element.WithItems).Raw}} for iteration. Error: %v", err)
		}
	}()

	func() {
		if err != nil {
			return
		}
		var ok bool
		iterlist, ok = iterlist_interface.([]interface{})
		if !ok {
			err = fmt.Errorf("Error casting iteration list into array: %s\n", iterlist_interface)
			return
		}

		wg.Add(len(iterlist))

		for _, element := range iterlist {
			expr_map["item"] = element
			new_var_map := make(map[string]interface{})
			var nil_err error
			var err_obj *error
			err_obj = &nil_err
			new_var_map_mutex := &sync.RWMutex{}
			{{if gt (len $element.Loop.Input) 0}}
			func() {
				defer var_map_mutex.RUnlock()
				var_map_mutex.RLock()
				var exerr error
				logger.logExpressionf("[DEBUG] Mapping arguments using main bucket %v ...", expr_map["main"])
				{{range $index2, $element2 := $element.Loop.Input}}
				new_var_map["{{$index2}}"], exerr = {{$.OrigSpec.Name}}_expr_{{ (index $.ExpressionMap $element2).Srno }}(expr_map)
				if exerr != nil {
					logger.logExpressionf("[WARN] Evaluating {{escapestring (index $.ExpressionMap $element2).Type}} expression {{escapestring (index $.ExpressionMap $element2).Raw}} for argument {{$index2}}. Failure: %v", exerr)
				} else {
					logger.logExpressionf("[DEBUG] Evaluating {{escapestring (index $.ExpressionMap $element2).Type}} expression {{escapestring (index $.ExpressionMap $element2).Raw}} for argument {{$index2}}. Result: %v", new_var_map["{{$index2}}"])
				}
				{{end}}
			}()
			{{end}}
			var_maps = append(var_maps, new_var_map)
			err_objs = append(err_objs, err_obj)


			go func() {
				var terr error
				defer func() {
					if r := recover(); r != nil {
						perr = r
					}
					if terr != nil {
						(*err_obj) = terr
						is_error = true
						err = terr
					}
					wg.Done()
				}()
				terr = {{printf "task_%s__%s" $.OrigSpec.Name $element.Loop.TaskName}}(new_var_map, new_var_map_mutex)
			}()
		}
		expr_map["item"] = nil

		wg.Wait()
	}()

	if perr != nil {
		panic(perr)
	}
	{{ end }}

	{{ if $element.Action }}
	if err != nil {
		logger.logActionf("[WARN] Failed to get response from {{ (index $.ActionMap $element.Action).Pascalized }} API: %v Err: %v Args: %v", resp, err, arg_map)
		is_error = true
		err_val := reflect.ValueOf(err)
		if err_val.Kind() == reflect.Struct {
			err_payload := err_val.FieldByName("Payload")
			if err_payload.IsValid() {
				expr_map["action"] = err_payload.Interface()
			}
		} else {
			expr_map["action_exception"] = err
		}
	}
	{{ else if $element.WithItems }}
	if err != nil {
		is_error = true
	}
	{{ end }}

	{{ if $element.WithItems }}
	{{ if $element.Loop.ErrorPublishList }}
	func() {
		defer var_map_mutex.Unlock()
		var_map_mutex.Lock()
		{{range $index2, $element2 := $element.Loop.ErrorPublishList}}
		var_map["{{$element2.VariableName}}"] = []interface{}{}
		{{end}}
		for index, element := range iterlist {
			expr_map["item"] = element
			var err_obj *error
			var iter_result interface{}
			var exerr error
			err_obj = err_objs[index]
			if err_obj != nil && *err_obj != nil {
				err_val := reflect.ValueOf(*err_obj)
				if err_val.Kind() == reflect.Struct {
					err_payload := err_val.FieldByName("Payload")
					if err_payload.IsValid() {
						expr_map["task"] = err_payload.Interface()
					}
				} else {
					expr_map["task_exception"] = *err_obj
				}
			}
			logger.logExpressionf("[DEBUG] Publishing variables using buckets %v ...", expr_map)
			{{range $index2, $element2 := $element.Loop.ErrorPublishList}}
			iter_result, exerr = {{$.OrigSpec.Name}}_expr_{{ (index $.ExpressionMap $element2.ExpressionName).Srno }}(expr_map)
			if exerr != nil {
				iter_result = nil
				logger.logExpressionf("[WARN] Evaluating {{escapestring (index $.ExpressionMap $element2.ExpressionName).Type}} expression {{escapestring (index $.ExpressionMap $element2.ExpressionName).Raw}} for publishing variable {{$element2.VariableName}}. Failure: %v", exerr)
			} else {
				logger.logExpressionf("[DEBUG] Evaluating {{escapestring (index $.ExpressionMap $element2.ExpressionName).Type}} expression {{escapestring (index $.ExpressionMap $element2.ExpressionName).Raw}} for publishing variable {{$element2.VariableName}}. Result: %v", iter_result)
			}
			var_map["{{$element2.VariableName}}"] = append(var_map["{{$element2.VariableName}}"].([]interface{}), iter_result)
			{{end}}
		}
	}()
	{{ end }}
	{{ if $element.Loop.PublishList }}
	func() {
		defer var_map_mutex.Unlock()
		var_map_mutex.Lock()
		{{range $index2, $element2 := $element.Loop.PublishList}}
		var_map["{{$element2.VariableName}}"] = []interface{}{}
		{{end}}
		for index, element := range iterlist {
			expr_map["item"] = element
			expr_map["task"] = var_maps[index]
			var err_obj *error
			var iter_result interface{}
			var exerr error
			err_obj = err_objs[index]
			if err_obj != nil && *err_obj != nil {
				expr_map["task"] = nil
			}
			logger.logExpressionf("[DEBUG] Publishing variables using buckets %v ...", expr_map)
			{{range $index2, $element2 := $element.Loop.PublishList}}
			iter_result, exerr = {{$.OrigSpec.Name}}_expr_{{ (index $.ExpressionMap $element2.ExpressionName).Srno }}(expr_map)
			if exerr != nil {
				iter_result = nil
				logger.logExpressionf("[WARN] Evaluating {{escapestring (index $.ExpressionMap $element2.ExpressionName).Type}} expression {{escapestring (index $.ExpressionMap $element2.ExpressionName).Raw}} for publishing variable {{$element2.VariableName}}. Failure: %v", exerr)
			} else {
				logger.logExpressionf("[DEBUG] Evaluating {{escapestring (index $.ExpressionMap $element2.ExpressionName).Type}} expression {{escapestring (index $.ExpressionMap $element2.ExpressionName).Raw}} for publishing variable {{$element2.VariableName}}. Result: %v", iter_result)
			}
			var_map["{{$element2.VariableName}}"] = append(var_map["{{$element2.VariableName}}"].([]interface{}), iter_result)
			{{end}}
		}
	}()
	{{ end }}
	{{ end }}
	{{if gt (len $element.ErrorPublishList) 0}}
	if is_error {
		func() {
			defer var_map_mutex.Unlock()
			var_map_mutex.Lock()
			var exerr error
			logger.logExpressionf("[DEBUG] Publishing variables using buckets %v ...", expr_map)
			{{range $index2, $element2 := $element.ErrorPublishList}}
			var_map["{{$element2.VariableName}}"], exerr = {{$.OrigSpec.Name}}_expr_{{ (index $.ExpressionMap $element2.ExpressionName).Srno }}(expr_map)
			if exerr != nil {
				logger.logExpressionf("[WARN] Evaluating {{escapestring (index $.ExpressionMap $element2.ExpressionName).Type}} expression {{escapestring (index $.ExpressionMap $element2.ExpressionName).Raw}} for publishing variable {{$element2.VariableName}}. Failure: %v", exerr)
			} else {
				logger.logExpressionf("[DEBUG] Evaluating {{escapestring (index $.ExpressionMap $element2.ExpressionName).Type}} expression {{escapestring (index $.ExpressionMap $element2.ExpressionName).Raw}} for publishing variable {{$element2.VariableName}}. Result: %v", var_map["{{$element2.VariableName}}"])
			}
			{{end}}
		}()
	}
	{{ end }}
	{{if gt (len $element.PublishList) 0}}
	if !is_error {
		func() {
			defer var_map_mutex.Unlock()
			var_map_mutex.Lock()
			var exerr error
			logger.logExpressionf("[DEBUG] Publishing variables using buckets %v ...", expr_map)
			{{range $index2, $element2 := $element.PublishList}}
			var_map["{{$element2.VariableName}}"], exerr = {{$.OrigSpec.Name}}_expr_{{ (index $.ExpressionMap $element2.ExpressionName).Srno }}(expr_map)
			if exerr != nil {
				logger.logExpressionf("[WARN] Evaluating {{escapestring (index $.ExpressionMap $element2.ExpressionName).Type}} expression {{escapestring (index $.ExpressionMap $element2.ExpressionName).Raw}} for publishing variable {{$element2.VariableName}}. Failure: %v", exerr)
			} else {
				logger.logExpressionf("[DEBUG] Evaluating {{escapestring (index $.ExpressionMap $element2.ExpressionName).Type}} expression {{escapestring (index $.ExpressionMap $element2.ExpressionName).Raw}} for publishing variable {{$element2.VariableName}}. Result: %v", var_map["{{$element2.VariableName}}"])
			}
			{{end}}
		}()
	}
	{{ end }}

	{{range $index2, $element2 := $element.OnSuccessList}}
	var expr{{$element2.Srno}} interface{}
	var e{{$element2.Srno}} error
	{{end}}
	{{range $index2, $element2 := $element.OnErrorList}}
	var eexpr{{$element2.Srno}} interface{}
	var ee{{$element2.Srno}} error
	{{end}}
	{{if gt (len $element.OnErrorList) 0}}
	if is_error {
		func() {
			defer var_map_mutex.RUnlock()
			var_map_mutex.RLock()
			logger.logExpressionf("[DEBUG] Evaluating on-error conditionals using buckets %v ...", expr_map)
			{{range $index2, $element2 := $element.OnErrorList}}
			eexpr{{$element2.Srno}}, ee{{$element2.Srno}} = {{$.OrigSpec.Name}}_expr_{{ (index $.ExpressionMap $element2.ExpressionName).Srno }}(expr_map)
			if ee{{$element2.Srno}} != nil {
				logger.logExpressionf("[WARN] Evaluating {{escapestring (index $.ExpressionMap $element2.ExpressionName).Type}} expression {{escapestring (index $.ExpressionMap $element2.ExpressionName).Raw}} for task {{$element2.TaskName}}. Failure: %v", ee{{$element2.Srno}})
			} else {
				logger.logExpressionf("[DEBUG] Evaluating {{escapestring (index $.ExpressionMap $element2.ExpressionName).Type}} expression {{escapestring (index $.ExpressionMap $element2.ExpressionName).Raw}} for task {{$element2.TaskName}}. Result: %v", eexpr{{$element2.Srno}})
			}
			{{end}}
		}()
	}
	{{end}}
	{{if gt (len $element.OnSuccessList) 0}}
	if !is_error {
		func() {
			defer var_map_mutex.RUnlock()
			var_map_mutex.RLock()
			logger.logExpressionf("[DEBUG] Evaluating on-success conditionals using buckets %v ...", expr_map)
			{{range $index2, $element2 := $element.OnSuccessList}}
			expr{{$element2.Srno}}, e{{$element2.Srno}} = {{$.OrigSpec.Name}}_expr_{{ (index $.ExpressionMap $element2.ExpressionName).Srno }}(expr_map)
			if ee{{$element2.Srno}} != nil {
				logger.logExpressionf("[WARN] Evaluating {{escapestring (index $.ExpressionMap $element2.ExpressionName).Type}} expression {{escapestring (index $.ExpressionMap $element2.ExpressionName).Raw}} for task {{$element2.TaskName}}. Failure: %v", e{{$element2.Srno}})
			} else {
				logger.logExpressionf("[DEBUG] Evaluating {{escapestring (index $.ExpressionMap $element2.ExpressionName).Type}} expression {{escapestring (index $.ExpressionMap $element2.ExpressionName).Raw}} for task {{$element2.TaskName}}. Result: %v", expr{{$element2.Srno}})
			}
			{{end}}
		}()
	}
	{{end}}

	{{ if gt (len $element.OnErrorList) 0 }}
	if is_error {
		{{if eq (len $element.OnErrorList) 1}}
		if ee1 == nil && eexpr1.(bool) {
			{{printf "task_%s__%s" $.OrigSpec.Name (index $element.OnErrorList 0).TaskName}}(var_map, var_map_mutex)
		}
		{{else if gt (len $element.OnErrorList) 1}}
		var wg sync.WaitGroup
		var wgerr interface{}
		wgerr = nil
		{{range $index2, $element2 := $element.OnErrorList}}
		if ee{{$element2.Srno}} == nil && eexpr{{$element2.Srno}}.(bool) {
			wg.Add(1)
			go func() {
				defer func () {
					if r := recover(); r != nil {
						wgerr = r
					}
					wg.Done()
				}()
				{{printf "task_%s__%s" $.OrigSpec.Name $element2.TaskName}}(var_map, var_map_mutex)
			}()
		}
		{{end}}
		wg.Wait()
		{{end}}
	}
	{{ end }}
	{{ if gt (len $element.OnSuccessList) 0 }}
	if !is_error {
		{{if eq (len $element.OnSuccessList) 1}}
		if e1 == nil && expr1.(bool) {
			{{printf "task_%s__%s" $.OrigSpec.Name (index $element.OnSuccessList 0).TaskName}}(var_map, var_map_mutex)
		}
		{{else if gt (len $element.OnSuccessList) 1}}
		var wg sync.WaitGroup
		var wgerr interface{}
		wgerr = nil
		{{range $index2, $element2 := $element.OnSuccessList}}
		if e{{$element2.Srno}} == nil && expr{{$element2.Srno}}.(bool) {
			wg.Add(1)
			go func() {
				defer func () {
					if r := recover(); r != nil {
						wgerr = r
					}
					wg.Done()
				}()
				{{printf "task_%s__%s" $.OrigSpec.Name $element2.TaskName}}(var_map, var_map_mutex)
			}()
		}
		{{end}}
		wg.Wait()
		{{end}}
	}
	{{ end }}

	{{range $index2, $element2 := $element.OnCompleteList}}
	logger.logExpressionf("[DEBUG] Evaluating on-complete conditional using buckets %v ...", expr_map)
	onc_expr{{$element2.Srno}}, onc_e{{$element2.Srno}} := {{$.OrigSpec.Name}}_expr_{{ (index $.ExpressionMap $element2.ExpressionName).Srno }}(expr_map)
	if ee{{$element2.Srno}} != nil {
		logger.logExpressionf("[WARN] Evaluating {{escapestring (index $.ExpressionMap $element2.ExpressionName).Type}} expression {{escapestring (index $.ExpressionMap $element2.ExpressionName).Raw}} for task {{$element2.TaskName}}. Failure: %v", onc_e{{$element2.Srno}})
	} else {
		logger.logExpressionf("[DEBUG] Evaluating {{escapestring (index $.ExpressionMap $element2.ExpressionName).Type}} expression {{escapestring (index $.ExpressionMap $element2.ExpressionName).Raw}} for task {{$element2.TaskName}}. Result: %v", onc_expr{{$element2.Srno}})
	}
	if onc_e{{$element2.Srno}} == nil && onc_expr{{$element2.Srno}}.(bool) {
		{{printf "task_%s__%s" $.OrigSpec.Name $element2.TaskName}}(var_map, var_map_mutex)
	}
	{{end}}

	{{if gt (len $element.CompletePublishList) 0}}
	func() {
		defer var_map_mutex.Unlock()
		var_map_mutex.Lock()
		{{range $index2, $element2 := $element.CompletePublishList}}
		var_map["{{$element2.VariableName}}"], _ = {{$.OrigSpec.Name}}_expr_{{ (index $.ExpressionMap $element2.ExpressionName).Srno }}(expr_map)
		{{end}}
	}()
	{{end}}

	if is_error {
		return err
	} else {
		return nil
	}
}
{{end}}

{{range $expr, $expr_obj := .ExpressionMap}}
// {{$expr}} -> {{$expr_obj}}
func {{$.OrigSpec.Name}}_expr_{{$expr_obj.Srno}}(var_map map[string]interface{}) (result interface{}, err error) {
	{{if eq $expr_obj.Type "json"}}err = json.Unmarshal([]byte("{{escapestring $expr_obj.Raw}}"), &result){{else if eq $expr_obj.Type "jmes"}}result, err = {{$.OrigSpec.Name}}_eval_{{$expr_obj.Srno}}.Search(var_map){{else if eq $expr_obj.Type "jngo"}}var t_result string
	t_result, err = {{$.OrigSpec.Name}}_eval_{{$expr_obj.Srno}}.Execute(pongo2.Context(var_map))
	if err != nil {
		result = nil
		return
	}
	err = json.Unmarshal([]byte(t_result), &result){{end}}
	if err == nil {
		result = resolvePointers(result)
	}
	return
}
{{end}}
