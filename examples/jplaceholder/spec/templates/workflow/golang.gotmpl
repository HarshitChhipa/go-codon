{{define "outputmapexpander"}}map[string]interface{} {
	{{range $key, $value := .Children}}
	{{if eq $value.Type "map"}}
	"{{$key}}": {{template "outputmapexpander" $value}},
	{{else}}
	"{{$key}}": maybe({{$value.FlowName}}_expr_{{$value.ExpressionSrno}}(&expr_map)),
	{{end}}
	{{end}}
}{{end}}
package workflows
{{if .OrigSpec.References.go}}
import (
	config "github.com/grofers/go-codon/runtime/config"
	{{range $index, $element := .OrigSpec.References.go}}
	{{$index}} "{{$element}}"
	{{end}}
)
{{end}}

func {{ pascalize .OrigSpec.Name }}(var_map *map[string]interface{}) interface{} {
	var err interface{}
	err = nil

	var var_map_mutex = &sync.RWMutex{}
	{{ if eq (len .OrigSpec.Start) 1 }}
	{{printf "task_%s__%s" $.OrigSpec.Name (index $.OrigSpec.Start 0)}}(var_map, var_map_mutex)
	{{ else if gt (len .OrigSpec.Start) 1 }}
	var wg sync.WaitGroup
	wg.Add({{len .OrigSpec.Start}})
	{{ range $index, $element := .OrigSpec.Start }}
	go func() {
		defer func () {
			if r := recover(); r != nil {
				err = r
			}
			wg.Done()
		}()
		{{printf "task_%s__%s" $.OrigSpec.Name $element}}(var_map, var_map_mutex)
	}()
	{{ end }}
	wg.Wait()
	{{ end }}

	if err != nil {
		panic(err)
	}

	expr_map := make(map[string]interface{})
	expr_map["main"] = var_map
	expr_map["constants"] = config.YmlConfig.Constants

	defer var_map_mutex.RUnlock()
	var_map_mutex.RLock()
	{{if eq .LanguageSpec.OutputObj.Type "map"}}
	ret_map := {{template "outputmapexpander" .LanguageSpec.OutputObj}}
	{{else}}
	ret_map := maybe({{$.OrigSpec.Name}}_expr_{{.LanguageSpec.OutputObj.ExpressionSrno}}(&expr_map))
	{{end}}

	return ret_map
}

{{range $expr, $expr_obj := .ExpressionMap}}
{{if eq $expr_obj.Type "jmes"}}var {{$.OrigSpec.Name}}_eval_{{$expr_obj.Srno}} = jmespath.MustCompile("{{escapestring $expr_obj.Raw}}"){{end}}{{if eq $expr_obj.Type "jngo"}}var {{$.OrigSpec.Name}}_eval_{{$expr_obj.Srno}} = pongo2.Must(pongo2.FromString("{{escapestring $expr_obj.Raw}}")){{end}}{{end}}

{{range $index, $element := .OrigSpec.Tasks}}
func {{printf "task_%s__%s" $.OrigSpec.Name $index}}(var_map *map[string]interface{}, var_map_mutex *sync.RWMutex) error {
	expr_map := make(map[string]interface{})
	expr_map["main"] = var_map
	expr_map["constants"] = config.YmlConfig.Constants
	{{if $element.Action}}
	arg_map := make(map[string]interface{})
	{{if gt (len $element.Input) 0}}
	func() {
		defer var_map_mutex.RUnlock()
		var_map_mutex.RLock()
		{{range $index2, $element2 := $element.Input}}
		arg_map["{{$index2}}"], _ = {{$.OrigSpec.Name}}_expr_{{ (index $.ExpressionMap $element2).Srno }}(&expr_map){{end}}
	}()
	{{end}}
	{{if $element.Timeout}}arg_map["_timeout"] = int64({{$element.Timeout}}){{end}}
	{{ if eq (index $.ActionMap $element.Action).Type "clients" }}
	log.Println("[DEBUG] Sending a request to {{ (index $.ActionMap $element.Action).Pascalized }} API")
	resp, err := {{ (index $.ActionMap $element.Action).Pascalized }}(&arg_map)
	if err != nil {
		log.Println("[WARN] Failed to get response from {{ (index $.ActionMap $element.Action).Pascalized }} API: ", resp, " Err: ", err, " Args: ", arg_map)
		defer var_map_mutex.Unlock()
		var_map_mutex.Lock()
		{{range $index2, $element2 := $element.ErrorPublish}}
		(*var_map)["{{$index2}}"], _ = {{$.OrigSpec.Name}}_expr_{{ (index $.ExpressionMap $element2).Srno }}(&expr_map)
		{{end}}
		return err
	}
	resp_map := resp.Payload
	log.Println("[DEBUG] Received response from {{ (index $.ActionMap $element.Action).Pascalized }} API: ", resp_map)
	{{ else }}
	resp_map, err := {{ (index $.ActionMap $element.Action).Pascalized }}(&arg_map)
	if err != nil {
		defer var_map_mutex.Unlock()
		var_map_mutex.Lock()
		{{range $index2, $element2 := $element.ErrorPublish}}
		(*var_map)["{{$index2}}"], _ = {{$.OrigSpec.Name}}_expr_{{ (index $.ExpressionMap $element2).Srno }}(&expr_map)
		{{end}}
		return err
	}
	{{ end }}
	expr_map["action"] = resp_map
	{{ else if $element.WithItems }}
	var err interface{} = nil
	var wg sync.WaitGroup
	var iterlist_interface interface{}
	func() {
		defer var_map_mutex.RUnlock()
		var_map_mutex.RLock()
		iterlist_interface, _ = {{$.OrigSpec.Name}}_expr_{{ (index $.ExpressionMap $element.WithItems).Srno }}(&expr_map)
	}()

	iterlist, ok := iterlist_interface.([]interface{})
	if !ok {
		return fmt.Errorf("Error casting iteration list into array: %s\n", iterlist_interface)
	}

	wg.Add(len(iterlist))

	var_maps := []map[string]interface{} {}

	for _, element := range iterlist {
		expr_map["item"] = element
		new_var_map := make(map[string]interface{})
		new_var_map_mutex := &sync.RWMutex{}
		{{if gt (len $element.Loop.Input) 0}}
		func() {
			defer var_map_mutex.RUnlock()
			var_map_mutex.RLock()
			{{range $index2, $element2 := $element.Loop.Input}}
			new_var_map["{{$index2}}"], _ = {{$.OrigSpec.Name}}_expr_{{ (index $.ExpressionMap $element2).Srno }}(&expr_map){{end}}
		}()
		{{end}}
		var_maps = append(var_maps, new_var_map)

		go func() {
			defer func() {
				if r := recover(); r != nil {
					err = r
				}
				wg.Done()
			}()
			{{printf "task_%s__%s" $.OrigSpec.Name $element.Loop.TaskName}}(&new_var_map, new_var_map_mutex)
		}()
	}
	expr_map["item"] = nil

	wg.Wait()

	if err != nil {
		panic(err)
	}

	func() {
		defer var_map_mutex.Unlock()
		var_map_mutex.Lock()
		{{range $index2, $element2 := $element.Loop.Publish}}
		(*var_map)["{{$index2}}"] = []interface{}{}
		{{end}}
		for index, element := range iterlist {
			expr_map["item"] = element
			expr_map["task"] = var_maps[index]
			{{range $index2, $element2 := $element.Loop.Publish}}
			(*var_map)["{{$index2}}"] = append((*var_map)["{{$index2}}"].([]interface{}), maybe({{$.OrigSpec.Name}}_expr_{{ (index $.ExpressionMap $element2).Srno }}(&expr_map)))
			{{end}}
		}
	}()
	{{end}}
	{{if gt (len $element.Publish) 0}}
	func() {
		defer var_map_mutex.Unlock()
		var_map_mutex.Lock()
		{{range $index2, $element2 := $element.Publish}}
		(*var_map)["{{$index2}}"], _ = {{$.OrigSpec.Name}}_expr_{{ (index $.ExpressionMap $element2).Srno }}(&expr_map)
		{{end}}
	}()
	{{end}}
	{{range $index2, $element2 := $element.OnSuccessList}}
	var expr{{$element2.Srno}} interface{}
	var e{{$element2.Srno}} error
	{{end}}
	{{if gt (len $element.OnSuccessList) 0}}
	func() {
		defer var_map_mutex.RUnlock()
		var_map_mutex.RLock()
		{{range $index2, $element2 := $element.OnSuccessList}}
		expr{{$element2.Srno}}, e{{$element2.Srno}} = {{$.OrigSpec.Name}}_expr_{{ (index $.ExpressionMap $element2.ExpressionName).Srno }}(&expr_map){{end}}
	}()
	{{end}}

	{{if eq (len $element.OnSuccessList) 1}}
	if e1 == nil && expr1.(bool) {
		{{printf "task_%s__%s" $.OrigSpec.Name (index $element.OnSuccessList 0).TaskName}}(var_map, var_map_mutex)
	}
	{{else if gt (len $element.OnSuccessList) 1}}
	var wg sync.WaitGroup
	var wgerr interface{}
	wgerr = nil
	{{range $index2, $element2 := $element.OnSuccessList}}
	if e{{$element2.Srno}} == nil && expr{{$element2.Srno}}.(bool) {
		wg.Add(1)
		go func() {
			defer func () {
				if r := recover(); r != nil {
					wgerr = r
				}
				wg.Done()
			}()
			{{printf "task_%s__%s" $.OrigSpec.Name $element2.TaskName}}(var_map, var_map_mutex)
		}()
	}
	{{end}}
	wg.Wait()
	{{range $index2, $element2 := $element.OnCompleteList}}
	oncexpr{{$element2.Srno}}, e{{$element2.Srno}} := {{$.OrigSpec.Name}}_expr_{{ (index $.ExpressionMap $element2.ExpressionName).Srno }}(&expr_map){{end}}
	{{range $index2, $element2 := $element.OnCompleteList}}
	if e{{$element2.Srno}} == nil && oncexpr{{$element2.Srno}}.(bool) {
		{{printf "task_%s__%s" $.OrigSpec.Name $element2.TaskName}}(var_map, var_map_mutex)
	}
	{{end}}
	{{end}}
	return nil
}
{{end}}

{{range $expr, $expr_obj := .ExpressionMap}}
// {{$expr}} -> {{$expr_obj}}
func {{$.OrigSpec.Name}}_expr_{{$expr_obj.Srno}}(var_map *map[string]interface{}) (result interface{}, err error) {
	{{if eq $expr_obj.Type "json"}}err = json.Unmarshal([]byte("{{escapestring $expr_obj.Raw}}"), &result){{else if eq $expr_obj.Type "jmes"}}result, err = {{$.OrigSpec.Name}}_eval_{{$expr_obj.Srno}}.Search(var_map){{else if eq $expr_obj.Type "jngo"}}var t_result string
	t_result, err = {{$.OrigSpec.Name}}_eval_{{$expr_obj.Srno}}.Execute(pongo2.Context(*var_map))
	if err != nil {
		result = nil
		return
	}
	err = json.Unmarshal([]byte(t_result), &result){{end}}
	if err == nil {
		result = resolvePointers(result)
	}
	return
}
{{end}}
